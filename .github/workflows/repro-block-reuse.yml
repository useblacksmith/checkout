name: Repro Block Reuse

on:
  workflow_dispatch:
  push:
    branches:
      - adityamaru/fix-pack-idx-corruption

jobs:
  block-reuse-test:
    runs-on: blacksmith
    strategy:
      fail-fast: false
      matrix:
        shard: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
    steps:
      # First checkout gets the action source code (standard GH action)
      - name: Checkout action code
        uses: actions/checkout@v4

      # This uses our blacksmith checkout action which mounts the sticky disk
      - name: Blacksmith checkout (mounts sticky disk)
        uses: ./
        with:
          path: workspace
          fetch-depth: 0

      - name: Block reuse repro
        run: |
          set -euo pipefail

          SHARD=${{ matrix.shard }}
          echo "=== SHARD $SHARD ==="

          # Find the sticky disk mount
          MOUNT=$(mount | grep blacksmith-git-mirror | awk '{print $3}')
          if [ -z "$MOUNT" ]; then
            echo "ERROR: No sticky disk mounted"
            exit 1
          fi
          echo "Sticky disk at: $MOUNT"
          DEV=$(df --output=source "$MOUNT" | tail -1)
          echo "Device: $DEV"
          echo "Data mode: $(cat /proc/fs/ext4/$(basename $DEV)/options 2>/dev/null | grep data)"

          # ---- DIAGNOSTIC: What's on the sticky disk? ----
          echo ""
          echo "========================================"
          echo "  DIAGNOSTICS: STICKY DISK CONTENTS"
          echo "========================================"
          echo "Mount root contents (ls -la):"
          ls -la "$MOUNT" || true
          echo ""
          echo "Mount root contents (recursive, max depth 2):"
          sudo find "$MOUNT" -maxdepth 2 -ls 2>/dev/null || true
          echo ""
          echo "Disk usage:"
          df -h "$MOUNT"
          echo ""
          echo "Mount count (tune2fs):"
          sudo tune2fs -l "$DEV" 2>/dev/null | grep -i "mount count" || true
          echo ""
          echo "Mirror exists? $(test -d "$MOUNT/v1" && echo 'YES (v1/ dir found)' || echo 'NO (v1/ dir missing - fresh disk!)')"
          echo "Test dir exists? $(test -d "$MOUNT/block_reuse_test" && echo 'YES' || echo 'NO')"
          echo "Phase file exists? $(test -f "$MOUNT/block_reuse_test/phase" && echo 'YES' || echo 'NO')"
          if [ -f "$MOUNT/block_reuse_test/phase" ]; then
            echo "Phase file content: $(cat "$MOUNT/block_reuse_test/phase")"
          fi
          echo "========================================"
          echo ""

          # Write test data INSIDE the .git mirror dir (we know mirror content survives).
          # Also write at mount root to compare. If mirror-internal survives but
          # mount-root doesn't, the backend is selectively preserving only mirror content.
          MIRROR_DIR="$MOUNT/v1/useblacksmith-checkout.git"
          TESTDIR="$MIRROR_DIR/block_reuse_test"
          TESTDIR_ROOT="$MOUNT/block_reuse_test"

          mkdir -p "$TESTDIR"
          sudo mkdir -p "$TESTDIR_ROOT"
          sudo chown runner:runner "$TESTDIR_ROOT"

          MANIFEST="$TESTDIR/manifest"
          RUNFILE="$TESTDIR/run_id"
          PHASE_FILE="$TESTDIR/phase"

          # Also write a parallel marker at mount root for comparison
          MANIFEST_ROOT="$TESTDIR_ROOT/manifest"
          RUNFILE_ROOT="$TESTDIR_ROOT/run_id"
          PHASE_FILE_ROOT="$TESTDIR_ROOT/phase"

          echo "Test dir (inside mirror): $TESTDIR"
          echo "Test dir (mount root):    $TESTDIR_ROOT"
          echo "Mirror-internal test dir exists? $(test -d "$TESTDIR" && echo 'YES' || echo 'NO')"
          echo "Mirror-internal phase file? $(test -f "$PHASE_FILE" && echo 'YES: '$(cat "$PHASE_FILE") || echo 'NO')"
          echo "Root test dir exists? $(test -d "$TESTDIR_ROOT" && echo 'YES' || echo 'NO')"
          echo "Root phase file? $(test -f "$PHASE_FILE_ROOT" && echo 'YES: '$(cat "$PHASE_FILE_ROOT") || echo 'NO')"

          # ---- PHASE 2: Verify previous run (if exists) ----
          if [ -f "$PHASE_FILE" ] && grep -q "ready" "$PHASE_FILE"; then
            echo ""
            echo "========================================"
            echo "  PHASE 2: VERIFYING PREVIOUS RUN"
            echo "========================================"

            PREV_RUN=$(cat "$RUNFILE" 2>/dev/null || echo "unknown")
            echo "Previous run ID: $PREV_RUN"

            # Force re-read from block device
            echo 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null

            TOTAL=0; GOOD=0; BAD=0; STALE=0; ZEROED=0; OTHER=0

            while IFS='|' read -r FNAME EXPECTED_MD5; do
              TOTAL=$((TOTAL + 1))
              if [ ! -f "$FNAME" ]; then
                BAD=$((BAD + 1))
                echo "MISSING: $FNAME"
                continue
              fi

              ACTUAL_MD5=$(md5sum "$FNAME" | awk '{print $1}')
              if [ "$ACTUAL_MD5" = "$EXPECTED_MD5" ]; then
                GOOD=$((GOOD + 1))
              else
                BAD=$((BAD + 1))
                CONTENT=$(cat "$FNAME" 2>/dev/null || true)
                if echo "$CONTENT" | grep -q "STALE_FHEAD"; then
                  STALE=$((STALE + 1))
                  echo "STALE: $FNAME -> $(head -c 60 "$FNAME")"
                else
                  FIRST_BYTES=$(xxd -l 16 -p "$FNAME" 2>/dev/null || true)
                  if [ "$FIRST_BYTES" = "00000000000000000000000000000000" ]; then
                    ZEROED=$((ZEROED + 1))
                    echo "ZEROED: $FNAME"
                  else
                    OTHER=$((OTHER + 1))
                    echo "CORRUPT: $FNAME expected=$EXPECTED_MD5 actual=$ACTUAL_MD5"
                    xxd -l 64 "$FNAME" || true
                  fi
                fi
              fi
            done < "$MANIFEST"

            echo ""
            echo "========== SHARD $SHARD VERIFY RESULTS =========="
            echo "Total:  $TOTAL"
            echo "Good:   $GOOD"
            echo "Bad:    $BAD (stale=$STALE zeroed=$ZEROED other=$OTHER)"

            if [ $BAD -gt 0 ]; then
              echo "::error::SHARD $SHARD: DATA LOSS DETECTED ($BAD/$TOTAL files corrupted: stale=$STALE zeroed=$ZEROED other=$OTHER)"
            fi
          else
            echo "No previous run to verify (first run for this sticky disk)."
          fi

          # ---- PHASE 1: Write test data for next run ----
          echo ""
          echo "========================================"
          echo "  PHASE 1: WRITING TEST DATA"
          echo "========================================"

          # Clean and recreate both test directories
          rm -rf "$TESTDIR"
          mkdir -p "$TESTDIR"
          sudo rm -rf "$TESTDIR_ROOT"
          sudo mkdir -p "$TESTDIR_ROOT"
          sudo chown runner:runner "$TESTDIR_ROOT"

          RUN_ID="shard${SHARD}-$(date +%Y%m%d-%H%M%S)-$$"
          echo "$RUN_ID" > "$RUNFILE"
          echo "$RUN_ID" > "$RUNFILE_ROOT"
          echo "Run ID: $RUN_ID"

          # Write large file to occupy blocks, then delete to free them
          echo "Writing 5MB stale file..."
          python3 -c "
          for i in range(50000):
              print(f'STALE_FHEAD_{i:06d}_' + 'X' * 70)
          " > "$TESTDIR/large_stale_file"
          sync

          echo "Deleting stale file to free blocks..."
          rm "$TESTDIR/large_stale_file"
          sync

          # Write small files (simulate git refs) to reuse freed blocks
          echo "Writing 200 small files (41 bytes) to BOTH locations..."
          > "$MANIFEST"
          > "$MANIFEST_ROOT"
          for i in $(seq 1 200); do
            CONTENT=$(printf 'OK_%s_%04d' "$RUN_ID" "$i" | sha1sum | head -c 40)

            # Inside mirror
            FNAME="$TESTDIR/ref_$(printf '%04d' $i)"
            printf '%s\n' "$CONTENT" > "$FNAME"
            echo "$FNAME|$(md5sum "$FNAME" | awk '{print $1}')" >> "$MANIFEST"

            # At mount root
            FNAME_ROOT="$TESTDIR_ROOT/ref_$(printf '%04d' $i)"
            printf '%s\n' "$CONTENT" > "$FNAME_ROOT"
            echo "$FNAME_ROOT|$(md5sum "$FNAME_ROOT" | awk '{print $1}')" >> "$MANIFEST_ROOT"
          done

          # Write medium files (simulate pack files)
          echo "Writing 10 x 1MB files..."
          for i in $(seq 1 10); do
            FNAME="$TESTDIR/pack_$(printf '%04d' $i)"
            dd if=/dev/urandom of="$FNAME" bs=1024 count=1024 2>/dev/null
            echo "$FNAME|$(md5sum "$FNAME" | awk '{print $1}')" >> "$MANIFEST"
          done

          sync
          echo "ready" > "$PHASE_FILE"
          echo "ready" > "$PHASE_FILE_ROOT"
          sync

          TOTAL_FILES=$(wc -l < "$MANIFEST")
          TOTAL_FILES_ROOT=$(wc -l < "$MANIFEST_ROOT")
          echo ""
          echo "Phase 1 complete: $TOTAL_FILES files (mirror), $TOTAL_FILES_ROOT files (root)."
          echo "Post step will sync -> umount -> commit snapshot."
          echo "Next run on this sticky disk will verify."
