name: Repro Block Reuse

on:
  workflow_dispatch:

jobs:
  block-reuse-test:
    runs-on: blacksmith
    strategy:
      fail-fast: false
      matrix:
        shard: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
    steps:
      # First checkout gets the action source code (standard GH action)
      - name: Checkout action code
        uses: actions/checkout@v4

      # This uses our blacksmith checkout action which mounts the sticky disk
      - name: Blacksmith checkout (mounts sticky disk)
        uses: ./
        with:
          path: workspace
          fetch-depth: 0

      - name: Block reuse repro
        run: |
          set -euo pipefail

          SHARD=${{ matrix.shard }}
          echo "=== SHARD $SHARD ==="

          # Find the sticky disk mount
          MOUNT=$(mount | grep blacksmith-git-mirror | awk '{print $3}')
          if [ -z "$MOUNT" ]; then
            echo "ERROR: No sticky disk mounted"
            exit 1
          fi
          echo "Sticky disk at: $MOUNT"
          DEV=$(df --output=source "$MOUNT" | tail -1)
          echo "Device: $DEV"
          echo "Data mode: $(cat /proc/fs/ext4/$(basename $DEV)/options 2>/dev/null | grep data)"

          # All shards see the same snapshot content (cloned from same parent).
          # Only one shard's commit wins as the new parent for the next run.
          # Each shard verifies whatever data the winning shard wrote last time,
          # then writes new data (one of these 25 commits will win for next time).
          TESTDIR="$MOUNT/.block_reuse_test"
          MANIFEST="$TESTDIR/manifest"
          RUNFILE="$TESTDIR/run_id"
          PHASE_FILE="$TESTDIR/phase"

          # ---- PHASE 2: Verify previous run (if exists) ----
          if [ -f "$PHASE_FILE" ] && grep -q "ready" "$PHASE_FILE"; then
            echo ""
            echo "========================================"
            echo "  PHASE 2: VERIFYING PREVIOUS RUN"
            echo "========================================"

            PREV_RUN=$(cat "$RUNFILE" 2>/dev/null || echo "unknown")
            echo "Previous run ID: $PREV_RUN"

            # Force re-read from block device
            echo 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null

            TOTAL=0; GOOD=0; BAD=0; STALE=0; ZEROED=0; OTHER=0

            while IFS='|' read -r FNAME EXPECTED_MD5; do
              TOTAL=$((TOTAL + 1))
              if [ ! -f "$FNAME" ]; then
                BAD=$((BAD + 1))
                echo "MISSING: $FNAME"
                continue
              fi

              ACTUAL_MD5=$(md5sum "$FNAME" | awk '{print $1}')
              if [ "$ACTUAL_MD5" = "$EXPECTED_MD5" ]; then
                GOOD=$((GOOD + 1))
              else
                BAD=$((BAD + 1))
                CONTENT=$(cat "$FNAME" 2>/dev/null || true)
                if echo "$CONTENT" | grep -q "STALE_FHEAD"; then
                  STALE=$((STALE + 1))
                  echo "STALE: $FNAME -> $(head -c 60 "$FNAME")"
                else
                  FIRST_BYTES=$(xxd -l 16 -p "$FNAME" 2>/dev/null || true)
                  if [ "$FIRST_BYTES" = "00000000000000000000000000000000" ]; then
                    ZEROED=$((ZEROED + 1))
                    echo "ZEROED: $FNAME"
                  else
                    OTHER=$((OTHER + 1))
                    echo "CORRUPT: $FNAME expected=$EXPECTED_MD5 actual=$ACTUAL_MD5"
                    xxd -l 64 "$FNAME" || true
                  fi
                fi
              fi
            done < "$MANIFEST"

            echo ""
            echo "========== SHARD $SHARD VERIFY RESULTS =========="
            echo "Total:  $TOTAL"
            echo "Good:   $GOOD"
            echo "Bad:    $BAD (stale=$STALE zeroed=$ZEROED other=$OTHER)"

            if [ $BAD -gt 0 ]; then
              echo "::error::SHARD $SHARD: DATA LOSS DETECTED ($BAD/$TOTAL files corrupted: stale=$STALE zeroed=$ZEROED other=$OTHER)"
            fi
          else
            echo "No previous run to verify (first run for this sticky disk)."
          fi

          # ---- PHASE 1: Write test data for next run ----
          echo ""
          echo "========================================"
          echo "  PHASE 1: WRITING TEST DATA"
          echo "========================================"

          rm -rf "$TESTDIR"
          mkdir -p "$TESTDIR"

          RUN_ID="shard${SHARD}-$(date +%Y%m%d-%H%M%S)-$$"
          echo "$RUN_ID" > "$RUNFILE"
          echo "Run ID: $RUN_ID"

          # Write large file to occupy blocks, then delete to free them
          echo "Writing 5MB stale file..."
          python3 -c "
          for i in range(50000):
              print(f'STALE_FHEAD_{i:06d}_' + 'X' * 70)
          " > "$TESTDIR/large_stale_file"
          sync

          echo "Deleting stale file to free blocks..."
          rm "$TESTDIR/large_stale_file"
          sync

          # Write small files (simulate git refs) to reuse freed blocks
          echo "Writing 200 small files (41 bytes)..."
          > "$MANIFEST"
          for i in $(seq 1 200); do
            FNAME="$TESTDIR/ref_$(printf '%04d' $i)"
            CONTENT=$(printf 'OK_%s_%04d' "$RUN_ID" "$i" | sha1sum | head -c 40)
            printf '%s\n' "$CONTENT" > "$FNAME"
            echo "$FNAME|$(md5sum "$FNAME" | awk '{print $1}')" >> "$MANIFEST"
          done

          # Write medium files (simulate pack files)
          echo "Writing 10 x 1MB files..."
          for i in $(seq 1 10); do
            FNAME="$TESTDIR/pack_$(printf '%04d' $i)"
            dd if=/dev/urandom of="$FNAME" bs=1024 count=1024 2>/dev/null
            echo "$FNAME|$(md5sum "$FNAME" | awk '{print $1}')" >> "$MANIFEST"
          done

          sync
          echo "ready" > "$PHASE_FILE"
          sync

          TOTAL_FILES=$(wc -l < "$MANIFEST")
          echo ""
          echo "Phase 1 complete: $TOTAL_FILES files written."
          echo "Post step will sync -> umount -> commit snapshot."
          echo "Next run on this sticky disk will verify."
